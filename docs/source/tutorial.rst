
Quick Start and Tutorials
====================================================================

The generic workflow of the simulation includes first generation of the spin bath in the material,
and second carrying the CCE dynamics calculations for the qubit interacting with this spin bath.

The simplest example includes the following steps:

1. Generate the ``BathCell`` object.
   Here we use the interface with ``ase`` which can generate unit cells of many
   materials conveniently and effortlessly. As an example, we import the diamond structure.

   .. literalinclude:: tutorials/nv_simple.py
      :language: python
      :lines: 1-5

2. Using the ``BathCell`` object, generate the spin bath
   of the most common isotopes in the material. Here we generate the spin bath
   of size 200 Angstrom and remove one carbon where our spin is located from the diamond crystal lattice.

   .. literalinclude:: tutorials/nv_simple.py
      :language: python
      :lines: 6

   This function returns ``BathArray`` instance, which contains names of the bath spins in ``'N'``, their coordinates
   in angstrom in ``'xyz'``, empty arrays of hyperfine couplings in kHz*rad in ``'A'``,
   and quadrupole couplings in kHz*rad in ``'Q'`` namefields.
   The hyperfine couplings will be generated by ``Simulator`` in the next step.

3. Setup the ``Simulator`` using the generated spin bath.
   The first required argument is the total spin of the central spin,
   ``r_bath``, ``r_dipole`` and ``order`` are convergence parameters,
   ``magnetic_field`` is the external applied magnetic field along z-axis,
   and ``pulses`` is number of decoupling :math:`\pi` pulses.

   .. literalinclude:: tutorials/nv_simple.py
      :language: python
      :lines: 8,9

   The hyperfine couplings are automatically generated at this step assuming point dipole-dipole interactions
   between central spin and bath spins.

4. Compute the coherence of the qubit using ``Simulator.compute`` method.

   .. literalinclude:: tutorials/nv_simple.py
      :language: python
      :lines: 11, 12

This function outputs Numpy array with the same shape as the ``time_points`` and
contains coherence function computed at each time step.
By default ``compute`` method uses conventional CCE to compute the coherence function.

The more detailed tutorials on the **pyCCE** usage are available in the examples below.


.. toctree::
   :maxdepth: 1
   :caption: Examples of using pyCCE Code

   tutorials/diamond_nv
   tutorials/sic_vv
   tutorials/si_shallow
   tutorials/classical_noise

The recommended order of the tutorials is from the top to bottom:

* :doc:`tutorials/diamond_nv` example goes through the example above in more details.
* :doc:`tutorials/sic_vv` tutorial explores the difference between
  generalized CCE with and without random bath state sampling.
  Also, in this example we introduce the way to work with DFT output of hyperfine tensors.
* :doc:`tutorials/si_shallow` example shows the way to include the custom hyperfine couplings for more
  delocalized defects in semiconductors.
* :doc:`tutorials/classical_noise` example explains the way to use autocorrelation function of the noise.


The examples above are also available as Jupyter notebooks in the Github repository.
